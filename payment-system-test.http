### 🏪 루프팩 BE L2 - 결제시스템 API 테스트
### 외부 PG 연동 및 Resilience 패턴이 적용된 결제시스템 테스트

### 환경 변수 설정
@commerce_base_url = http://localhost:8080
@pg_base_url = http://localhost:8082
@user_id = test-user-1

###
### 📋 사전 준비 - 테스트 데이터 생성 (DB에서 실행)
### 
### 다음 SQL을 DB에 먼저 실행하세요:
###
### -- 브랜드 생성
### INSERT INTO brand (id, name, created_at, updated_at) 
### VALUES (1, '삼성', NOW(), NOW());
### 
### -- 상품 생성  
### INSERT INTO product (id, name, value, quantity, brand_id, likes_count, created_at, updated_at)
### VALUES (1, '갤럭시 S24', 1200000, 100, 1, 0, NOW(), NOW());
###
### -- 사용자 생성
### INSERT INTO `user` (id, user_id, `value`, gender, created_at, updated_at)
### VALUES (1, 'test-user-1', 'TestUser1', 'MALE', NOW(), NOW());
### 
### -- 포인트 생성
### INSERT INTO point (user_id, point_balance)
### VALUES ('test-user-1', 5000000);

###
### 🏪 Commerce API 테스트
###

### 1. 주문 생성 (결제 자동 생성 + PG 호출)
# @no-cookie-jar
POST {{commerce_base_url}}/api/v1/orders
Content-Type: application/json
X-USER-ID: {{user_id}}

{
  "items": [
    {
      "productId": 1,
      "quantity": 1
    }
  ]
}

###
### 2. 주문 조회
GET {{commerce_base_url}}/api/v1/orders
X-USER-ID: {{user_id}}

###
### 3. 특정 주문 조회 (orderId 수정 필요)
GET {{commerce_base_url}}/api/v1/orders/1
X-USER-ID: {{user_id}}

###
### 4. 결제 콜백 - 성공
POST {{commerce_base_url}}/api/v1/payments/callback
Content-Type: application/json

{
  "transactionId": "TXN-SUCCESS-12345",
  "orderId": "1",
  "status": "SUCCESS",
  "message": "결제 성공"
}

###
### 5. 결제 콜백 - 실패
POST {{commerce_base_url}}/api/v1/payments/callback
Content-Type: application/json

{
  "transactionId": "TXN-FAILED-67890",
  "orderId": "2", 
  "status": "FAILED",
  "message": "카드 한도 초과"
}

###
###
### 🏦 PG Simulator 테스트  
###

### 1. 결제 요청 - 성공 케이스 (60% 확률)
POST {{pg_base_url}}/api/v1/payments
Content-Type: application/json
X-USER-ID: {{user_id}}

{
  "orderId": "ORDER-TEST-001",
  "cardType": "SAMSUNG",
  "cardNo": "1234-5678-9012-3456",
  "amount": 1200000,
  "callbackUrl": "{{commerce_base_url}}/api/v1/payments/callback"
}

###
### 2. 결제 요청 - 여러 번 테스트 (랜덤 결과)
POST {{pg_base_url}}/api/v1/payments
Content-Type: application/json
X-USER-ID: {{user_id}}

{
  "orderId": "ORDER-TEST-002",
  "cardType": "SAMSUNG", 
  "cardNo": "1234-5678-9012-3456",
  "amount": 500000,
  "callbackUrl": "{{commerce_base_url}}/api/v1/payments/callback"
}

###
### 3. 거래 상세 조회 (transactionKey 수정 필요)
GET {{pg_base_url}}/api/v1/payments/20250821:TR:abcdef
X-USER-ID: {{user_id}}

###
### 4. 주문별 거래 조회  
GET {{pg_base_url}}/api/v1/payments?orderId=ORDER-TEST-001
X-USER-ID: {{user_id}}

###
###
### 🛡️ Resilience 패턴 테스트
###

### 1. 서킷브레이커 테스트 - 연속 요청 (이걸 빠르게 10번 실행)
POST {{pg_base_url}}/api/v1/payments
Content-Type: application/json
X-USER-ID: {{user_id}}

{
  "orderId": "CIRCUIT-TEST-{{$random.integer(1000, 9999)}}",
  "cardType": "SAMSUNG",
  "cardNo": "1234-5678-9012-3456", 
  "amount": 10000,
  "callbackUrl": "{{commerce_base_url}}/api/v1/payments/callback"
}

###
### 2. 재시도 테스트 - PG 지연 확인
POST {{pg_base_url}}/api/v1/payments
Content-Type: application/json
X-USER-ID: {{user_id}}

{
  "orderId": "RETRY-TEST-{{$random.integer(1000, 9999)}}",
  "cardType": "SAMSUNG",
  "cardNo": "1234-5678-9012-3456",
  "amount": 20000,
  "callbackUrl": "{{commerce_base_url}}/api/v1/payments/callback"
}

###
###
### 🔄 전체 결제 플로우 테스트 시나리오
###

### 시나리오 1: 정상 결제 완료
### Step 1: 주문 생성
POST {{commerce_base_url}}/api/v1/orders
Content-Type: application/json
X-USER-ID: test-user-scenario1

{
  "items": [
    {
      "productId": 1,
      "quantity": 1
    }
  ]
}

### Step 2: 수동 PG 결제 (실제 환경에서는 자동)
POST {{pg_base_url}}/api/v1/payments  
Content-Type: application/json
X-USER-ID: test-user-scenario1

{
  "orderId": "1",
  "cardType": "SAMSUNG",
  "cardNo": "1234-5678-9012-3456",
  "amount": 1200000,
  "callbackUrl": "{{commerce_base_url}}/api/v1/payments/callback"
}

### Step 3: 결제 성공 콜백
POST {{commerce_base_url}}/api/v1/payments/callback
Content-Type: application/json

{
  "transactionId": "SCENARIO1-SUCCESS",
  "orderId": "1", 
  "status": "SUCCESS",
  "message": "결제 성공"
}

###
### 시나리오 2: 결제 실패
### Step 1: 주문 생성
POST {{commerce_base_url}}/api/v1/orders
Content-Type: application/json
X-USER-ID: test-user-scenario2

{
  "items": [
    {
      "productId": 1,
      "quantity": 1  
    }
  ]
}

### Step 2: 결제 실패 콜백
POST {{commerce_base_url}}/api/v1/payments/callback
Content-Type: application/json

{
  "transactionId": "SCENARIO2-FAILED",
  "orderId": "2",
  "status": "FAILED", 
  "message": "카드 한도 초과"
}

###
### 🎯 Round 7 Quest - ApplicationEvent 테스트
###

### 📋 이벤트 기반 기능 테스트

### 1. 상품 좋아요 (이벤트 분리: 좋아요 등록 vs 집계 업데이트)
POST {{commerce_base_url}}/api/v1/products/1/likes
Content-Type: application/json
X-USER-ID: {{user_id}}

{}

###
### 2. 상품 좋아요 취소 (eventual consistency 테스트)
DELETE {{commerce_base_url}}/api/v1/products/1/likes
Content-Type: application/json
X-USER-ID: {{user_id}}

###
### 3. 상품 조회 (사용자 행동 추적 이벤트)
GET {{commerce_base_url}}/api/v1/products/1
X-USER-ID: {{user_id}}

###
### 4. 상품 목록 조회 (사용자 행동 추적)
GET {{commerce_base_url}}/api/v1/products
X-USER-ID: {{user_id}}

###
### 🎯 주문-결제 이벤트 분리 테스트

### 1. 쿠폰 포함 주문 생성 (이벤트 분리: 주문 생성 → 쿠폰 사용 → 결제 → 데이터 플랫폼)
POST {{commerce_base_url}}/api/v1/orders
Content-Type: application/json
X-USER-ID: {{user_id}}

{
  "items": [
    {
      "productId": 1,
      "quantity": 1
    }
  ],
  "couponId": null
}

###
### 2. 주문 생성 후 상태 변화 확인 (PENDING → COMPLETED/PAYMENT_FAILED)
GET {{commerce_base_url}}/api/v1/orders
X-USER-ID: {{user_id}}

###
### 🔄 결제 실패 → PAYMENT_FAILED 상태 테스트

### 1. 결제 실패 시뮬레이션
POST {{commerce_base_url}}/api/v1/payments/callback
Content-Type: application/json

{
  "transactionId": "TXN-FAILED-TEST",
  "orderId": "1",
  "status": "FAILED",
  "message": "결제 실패 테스트"
}

###
### 2. PAYMENT_FAILED 상태 확인
GET {{commerce_base_url}}/api/v1/orders/1

###
### 🔍 상태 확인 및 모니터링
###

### 1. 사용자 주문 목록
GET {{commerce_base_url}}/api/v1/orders
X-USER-ID: {{user_id}}

###
### 2. 특정 주문 상태
GET {{commerce_base_url}}/api/v1/orders/1

###
### 3. PG 시뮬레이터 상태 (비공식)
GET {{pg_base_url}}/

###
###
### 📊 성능 및 부하 테스트
###

### 동시성 테스트 - 이걸 여러 탭에서 동시 실행
POST {{commerce_base_url}}/api/v1/orders
Content-Type: application/json
X-USER-ID: concurrent-user-{{$random.integer(1, 100)}}

{
  "items": [
    {
      "productId": 1,
      "quantity": 1
    }
  ]
}

### 
### 🚨 장애 시뮬레이션
### 

### PG 서버 다운 시뮬레이션 - PG 서버 종료 후 실행
POST {{commerce_base_url}}/api/v1/orders
Content-Type: application/json
X-USER-ID: failover-test

{
  "items": [
    {
      "productId": 1,
      "quantity": 1
    }
  ]
}

###
### 📝 테스트 결과 확인 포인트:
###
### ✅ 주문 생성 시 Payment 엔티티도 함께 생성되는지 확인
### ✅ PG 호출이 실제로 이루어지는지 로그 확인  
### ✅ 타임아웃 발생 시 PENDING 상태로 유지되는지 확인
### ✅ 서킷브레이커 작동 시 즉시 폴백 응답하는지 확인
### ✅ 콜백 처리 시 Payment와 Order 상태 동기화 확인
### ✅ 스케줄러가 PENDING 결제를 복구하는지 확인 (5분 대기)
###
### 🎯 Round 7 Quest 확인 포인트:
### ✅ 좋아요 등록은 즉시 완료, 집계는 비동기로 처리되는지 확인
### ✅ 집계 실패해도 좋아요는 정상 완료되는지 확인 (eventual consistency)
### ✅ 주문 생성 후 쿠폰 사용, 결제, 데이터 플랫폼 전송이 별도 트랜잭션으로 실행되는지 확인
### ✅ 사용자 행동 추적 이벤트가 비동기로 로깅되는지 확인
### ✅ 결제 실패 시 PAYMENT_FAILED 상태로 변경되는지 확인 (이전엔 PENDING 유지)
### ✅ PaymentRecoveryScheduler가 PAYMENT_FAILED 주문을 재시도하지 않는지 확인
### 
### 🎯 성공 기준:
### - 주문 생성: PENDING 상태로 생성
### - 결제 성공: PENDING → COMPLETED
### - 결제 실패: PENDING → PAYMENT_FAILED (NEW!)
### - PG 연동: 실제 API 호출 및 응답 처리
### - 이벤트 분리: 메인 로직과 부가 로직이 독립적인 트랜잭션으로 실행
### - Resilience: 장애 상황에서도 시스템 안정성 유지
### - Eventual Consistency: 좋아요 집계가 최종적으로 일관성을 맞추는지 확인
###